-----------------------------------------------------------------------------------------
Objectives
-----------------------------------------------------------------------------------------

In Experiment E19, we found that job length is a crucial parameter that could affect performance of our scheduling algorithms. We decide to study the influence of job length more systematically and this experiment would be the first step to approach the problem.

As a reminder, the term "job length" might be misleading because it actually means the number of jobs in a sequence. I apologize for inconvience introduced by the misnomer.

We will fix other input parameters in this experiment so that the variation of competitive ratio would only depend on job length. Since from researchers' perspective, the worst case is often more interesting than the others, we will choose the combination of input parameters that lead to the worst competitive ratio known to us.

As job length grows larger, the simulation time would increase proportionally. We planned to generate sequences with length 1k, 5k and even 10k, but the plan is adjustable if the simulation time turns out to be enormous.   

-----------------------------------------------------------------------------------------
Procedures
-----------------------------------------------------------------------------------------

Copy run2.sh from E22. Modify run3.sh to rename directories. 

There are three job bases. The first one is PUS(a = 1, b = 1000, f(y) = y^3) and the second one is PUS(a = 1, b = 1000, f(y) = y). There is also a PES job base: PES(beta = 100, f(y) = y). For this experiment, it is actually easier to generate jobs by hands, without using the bash file. After generation, rename them as PUS1, PUS2 and PES1.  

We generate PUS1 and PES1 multiple times. We let their job length be 1k, 5k and 10k. We then rename job bases by a suffix denoting the job length. For example, PUS1_5k. We only generate PUS2 once, using job length 1k. 

We will reuse the config files from E16.

Modify bash file run2.sh to automate running simulation. It is supposed to run algorithms 4-12 over job bases PUS2_1k and PES1_1k, run algorithms 1-3 on job sequences over job bases PUS1_xk and PES1_xk, and output result files to the proper directory with names being the index of algorithms. For example, when running algorithm 3 over job base PUS1_1k, we expect the result residing in result3_PUS1_1k. 

Use one kind of job length in a time. Since we need to know the running time to estimate the amound of work to do, we first just run simulation over job base with job length 1k. If it works, we then proceed to the longer job length.  

Modify the script E22/clip.py to pick up results

---------------------------------------------------------------------------------------
Result
---------------------------------------------------------------------------------------

Comparison of competitive ratios across 3 single-machine algorithms over PUS1 are listed below
(Some data are borrowed from previous experiment)

job length  Greedy-2    Greedy-1.5     Greedy-4    
400         1.62        1.52           1.56
1k          1.20        1.16           1.41
5k          1.17        1.10           1.31
10k         1.15        1.09           1.29

Comparison of competitive ratios across 3 single-machine algorithms over PES1 are listed below
(Some data are borrowed from previous experiment)

job length  Greedy-2    Greedy-1.5     Greedy-4
100         1.56        1.36           1.84
400         1.35        1.40           1.34     
1k          1.22        1.28           1.17
5k          1.15        1.22           1.07
10k         1.14        1.22           1.06

The CPU time spent on each experiment(each figure shown on the table) was at level of minutes.

Comparison of competitive ratios across 9 two-machine algorithms over PUS2 are listed below
(Some data are borrowed from previous experiment)

job length  FP(2,2) FP(1.5,4) FP(4,1.5) ABC(2,2) ABC(1.5,4) ABC(4,1.5) LVF(2,2) LVF(1.5,4) LVF(4,1.5) 
100         1.39    1.46      1.43      1.38     1.43       1.44       1.38     1.43       1.43
1k          1.21    1.19      1.19      1.21     1.19       1.19       1.21     1.19       1.19 

Comparison of competitive ratios across 9 two-machine algorithms over PES1 are listed below

job length  FP(2,2) FP(1.5,4) FP(4,1.5) ABC(2,2) ABC(1.5,4) ABC(4,1.5) LVF(2,2) LVF(1.5,4) LVF(4,1.5) 
100         1.21    1.31      1.28      1.21     1.29       1.29       1.21     1.27       1.28
1k          1.20    1.20      1.20      1.20     1.20       1.20       1.20     1.21       1.20

The CPU time spent on each experiment(each figure shown on the table) was between 100 and 400 minute.

The computation is summerized into a few patterns:

1. The competitive ratio and job length is not positively related. For single machine algorithms, a (locally)maximum competitive ratio 
seems to occur at jl < 1k. 
2. Every two-machine algorithms seem to have the same efficiency when the job length is raised to 1k, which indicates that job length 
could be dominatingly important.  
